import { ConfigService } from '../config/config.service';
import { IDataProperties, PermissionsEnum } from '../interfaces/interfaces';
import { AssetService } from './asset.service';
import { VerifiableCredential } from '../classes/verifiable-credential.class';
import { VerifiablePresentation } from '../classes/verifiable-presentation.class';
import { DIDDocument } from 'did-resolver';
export declare class EthereumAssetService implements AssetService {
    private readonly config;
    private runtime;
    private proofSignatureType;
    private runtimeConfig;
    private transactionOptions;
    private readonly loggerFormat;
    private readonly loggerOptions;
    private readonly logger;
    private readonly emptybytes32;
    private readonly assetHelperService;
    constructor(config: ConfigService);
    init(): Promise<void>;
    createAsset(assetName: string, initialDataProperties: IDataProperties, assetType?: string, accountAddress?: string): Promise<string>;
    private createAccountAsset;
    private createDataAndContractAsset;
    addInvolvedParties(assetDID: string, involvedPartiesDIDs: string[], permissions: PermissionsEnum[]): Promise<void>;
    getInvolvedParties(assetDID: string, permission: PermissionsEnum): Promise<string[]>;
    getDataProperty(assetDID: string, key: string, assetType?: string): Promise<string | null>;
    createDataProperty(assetDID: string, key: string, value: string, assetType?: string, changeable?: boolean): Promise<void>;
    resolveName(name: string): Promise<string | null>;
    setName(name: string, assetDID: string): Promise<void>;
    private labelhash;
    verifySignature: (signerDID: string, message: string, signature: string) => Promise<boolean>;
    private compareWithRecovered;
    getOwner(assetDID: string): Promise<string>;
    signMessage(message: string): Promise<string>;
    isValidDID(assetDID: string): Promise<boolean>;
    getDIDDocument(assetDID: string): Promise<DIDDocument>;
    setDIDDocument(didDocument: DIDDocument): Promise<void>;
    private addServicesToDIDDoc;
    private removeServicesFromDIDDoc;
    createVerifiableCredential(types: string[], credentialSubject: {
        id: string;
        [key: string]: any;
    } | Array<{
        id: string;
        [key: string]: any;
    }>, proofPurpose?: string, expirationDate?: string): Promise<VerifiableCredential>;
    createVerifiablePresentation(verifiableCredentials: Array<VerifiableCredential | string>, proofPurpose?: string, expirationDate?: string): Promise<VerifiablePresentation | string>;
    validateVerifiableCredential(verifiableCredential: VerifiableCredential | string): Promise<VerifiableCredential | undefined>;
    validateVerifiablePresentation(expectedSignerDid: string, verifiablePresentation: VerifiablePresentation | string): Promise<VerifiableCredential[]>;
    private getSignersFromDocument;
    updateDataProperty(assetDID: string, key: string, value: string, assetType?: string): Promise<void>;
    private getDataFromIpfs;
    convertAddressToDid(address: string): string;
    getAddressOfEthrDid(assetDid: string): string;
    private ipfsHashToBytes32;
    private bytes32ToIpfsHash;
    setAttestation(assetDID: string, topic: string, vc: string | VerifiableCredential): Promise<void>;
    getAttestations(assetDID: string, topic: string): Promise<Array<VerifiableCredential | string>>;
    private isContract;
    private isOwnerOfDIDDocument;
    private getIdOfSigner;
}
